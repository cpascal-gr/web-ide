import React, { useEffect, useState, useCallback } from "react";
import { useSelector, useDispatch } from "react-redux";
import ArrowDropUpIcon from "@material-ui/icons/ArrowDropUp";
import ArrowDropDownIcon from "@material-ui/icons/ArrowDropDown";
import MoreHorizIcon from "@material-ui/icons/MoreHoriz";
import FolderOpenIcon from "@material-ui/icons/FolderOpen";
import FolderIcon from "@material-ui/icons/Folder";
import SettingsIcon from "@material-ui/icons/Settings";
import DescriptionIcon from "@material-ui/icons/Description";
import InsertDriveFileIcon from "@material-ui/icons/InsertDriveFile";
import AddIcon from "@material-ui/icons/Add";
import EditIcon from "@material-ui/icons/EditTwoTone";
import DeleteIcon from "@material-ui/icons/DeleteTwoTone";
import Tooltip from "@material-ui/core/Tooltip";
import List from "@material-ui/core/List";
import ListItem from "@material-ui/core/ListItem";
import ListItemAvatar from "@material-ui/core/ListItemAvatar";
import ListItemIcon from "@material-ui/core/ListItemIcon";
import ListItemSecondaryAction from "@material-ui/core/ListItemSecondaryAction";
import ListItemText from "@material-ui/core/ListItemText";
import Avatar from "@material-ui/core/Avatar";
import IconButton from "@material-ui/core/IconButton";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faFolderPlus, faWindowClose } from "@fortawesome/free-solid-svg-icons";
import { useTheme } from "emotion-theming";
import * as SS from "./styles";
import { windowHeader as windowHeaderStyle } from "@styles/_common";
import { IDocument, IDocumentsMap, IProject } from "../Projects/types";
import { newDocument, deleteFile, renameDocument } from "../Projects/actions";
import {
    setFileTreePanelOpen,
    tabOpenByDocumentUid
} from "@comp/ProjectEditor/actions";
import { selectIsOwner } from "@comp/ProjectEditor/selectors";
import {
    append,
    assoc,
    assocPath,
    equals,
    find,
    findIndex,
    filter,
    last,
    pathOr,
    reduce,
    reject,
    reverse,
    pipe,
    prop,
    propEq,
    propOr,
    type as Rtype,
    values
} from "ramda";
import Tree, {
    MuiTreeData,
    MuiTreeLabelButtonData,
    MuiTreeIconButtonData
} from "material-ui-tree";
import { sortBy } from "lodash";

// const fileTreeDocs = documents
//       ? reduce((doc, acc) => {
//           assocPath(doc.path, )
//       }, [], documents)
// const fileTreeDocs = documents
//     ? sortBy(
//           values(documents).map((document: IDocument, index: number) => {
//               return {
//                   path: append(document.filename, document.path),
//                   type: document.type === "folder" ? "tree" : document.type,
//                   sha: document.documentUid
//               };
//           }),
//           [
//               function(d) {
//                   return d.path;
//               }
//           ]
//       )
//     : null;

const makeTree = (path, level, filelist) => {
    console.log(path, level, filelist);
    // var path = path || require('path');
    // var fs = fs || require('fs'),
    const currentFiles = filter(propEq("path", path || []), filelist);
    // const folderDoc = find(
    //     (x: any) =>
    //         propEq("documentUid", path || [], x) && propEq("type", "folder", x),
    //     filelist
    // );
    const newFileList = reject(propEq("path", path || []), filelist);
    return reduce(
        (acc, doc: IDocument) => {
            console.log(doc.type);
            if (propEq("type", "tree", doc) || propEq("type", "folder", doc)) {
                const folderPath = append(doc.documentUid, doc.path);
                console.log("FOLDER PATH!!!", folderPath);
                // console.log("FOLDER PATH", folderPath);
                const treeItem = {
                    folderName: doc.filename,
                    path: folderPath,
                    type: "tree",
                    sha: doc.documentUid,
                    unfoldFirst: false,
                    unfoldAll: false,
                    tree: makeTree(folderPath, { tree: [] }, newFileList)
                };
                const newSortedList = (pipe as any)(
                    append(treeItem)
                    // sortBy(i => last(prop("path", i)))
                )(acc.tree);
                return assoc("tree", newSortedList, acc);
            } else {
                // console.log(1111);
                const fileItem = {
                    path: append(doc.filename, doc.path),
                    type: doc.type,
                    sha: doc.documentUid
                };
                // console.log("fileI", fileItem, acc, acc.tree);
                const newSortedList = (pipe as any)(
                    append(fileItem)
                    // sortBy(
                    //     i => (console.log(i) as any) || last(prop("path", i))
                    // )
                )(acc.tree);
                // console.log("NEW SORTED LIST");
                return assoc("tree", newSortedList, acc);
            }
        },
        level,
        currentFiles
    );
};

const FileTree = () => {
    const activeProjectUid: string = useSelector(
        pathOr("", ["ProjectsReducer", "activeProjectUid"])
    );
    const isOwner = useSelector(selectIsOwner(activeProjectUid));
    const project: IProject | null = useSelector(
        pathOr(null, ["ProjectsReducer", "projects", activeProjectUid])
    ) as IProject | null;

    const documents: IDocumentsMap | null = useSelector(
        pathOr(null, [
            "ProjectsReducer",
            "projects",
            activeProjectUid,
            "documents"
        ])
    );

    const theme: any = useTheme();
    const dispatch = useDispatch();
    // const recur = (doc, acc, path) {
    //     if (isEmpty(path)) {
    //         const
    //         return acc;
    //     } else {
    //         const dir =
    //     }
    // }
    // const filterTree =
    //     documents &&
    //     (pipe as any)(
    //         values,
    //         (filter as any)(propEq("type", "folder")),
    //         reduce(
    //             (acc, folder: IDocument) =>
    //                 assocPath(
    //                     folder.path,
    //                     {
    //                         path: append(folder.filename, folder.path),
    //                         sha: folder.documentUid
    //                     },
    //                     acc
    //                 ),
    //             {}
    //         )
    //     )(documents);
    // console.log(filterTree);

    const [state, setState] = useState({
        expandAll: false,
        alignRight: false,
        unfoldAll: false,
        unfoldFirst: false,
        data: {}
        // data: {
        //     unfoldFirst: false,
        //     unfoldAll: false,
        //     path: project ? (project as IProject).name : "",
        //     type: "tree",
        //     tree: fileTreeDocs || [],
        //     sha: Math.random()
        // }
    });

    useEffect(() => {
        const newTree = makeTree(
            [],
            {
                unfoldFirst: false,
                unfoldAll: false,
                type: "tree",
                sha: Math.random(),
                tree: []
            },
            documents ? values(documents) : []
        );
        console.log("NEW TREE", newTree);
        setState(assoc("data", newTree, state));
    }, [documents]);
    // if (!equals(state.data.tree, fileTreeDocs)) {
    // setState(assocPath(["data", "tree"], fileTreeDocs));
    // }
    // console.log(state);
    const renderLabel = useCallback(
        (data, unfoldStatus) => {
            if (!project || !data) return <></>;
            const { path, type } = data;
            if (!path || !type) return <></>;
            const filename = last(path);
            const rootDirectoryElem = path === (project as IProject).name;
            let IconComp: any;
            if (type === "folder" || type === "tree") {
                if (rootDirectoryElem) {
                    IconComp = FolderOpenIcon;
                } else {
                    // >unfoldStatus ? FolderOpenIco : FolderIcon
                    IconComp = () => <span css={SS.directoryCloseIcon} />;
                }
            }
            if (type === "txt") {
                if (Rtype(data.sha) !== "String") return <></>;
                if (
                    filename.endsWith(".csd") ||
                    filename.endsWith(".sco") ||
                    filename.endsWith(".orc") ||
                    filename.endsWith(".udo") ||
                    false
                ) {
                    IconComp = DescriptionIcon;
                } else {
                    IconComp = InsertDriveFileIcon;
                }
            } else if (type === "bin") {
                IconComp = () => <span css={SS.mediaIcon} />;
            }
            const onFileClick = e => {
                dispatch(tabOpenByDocumentUid(data.sha, activeProjectUid));
            };
            return (
                <div onClick={onFileClick}>
                    <span css={SS.fileTreeNode}>
                        <IconComp css={SS.fileIcon} />
                        <p onClick={onFileClick} css={SS.fileTreeNodeText}>
                            {path}
                        </p>
                    </span>
                </div>
            );
        },
        [dispatch, project, activeProjectUid]
    );

    const getActionsData = useCallback(
        (
            data: MuiTreeData,
            path: number[],
            unfoldStatus: boolean,
            toggleFoldStatus: () => void
        ): (MuiTreeLabelButtonData | MuiTreeIconButtonData)[] => {
            const { type } = data;
            if (type === "tree") {
                if (!unfoldStatus) {
                    toggleFoldStatus();
                }
                return {
                    icon: <AddIcon style={{ display: "none" }} />,
                    label: "",
                    hint: "Insert file",
                    onClick: () =>
                        project &&
                        dispatch(
                            newDocument((project as IProject).projectUid, "")
                        )
                } as any;
            }
            return isOwner
                ? [
                      {
                          icon: <EditIcon css={SS.editIcon} />,
                          hint: `Rename ${propOr("", "path", data)}`,
                          onClick: () =>
                              dispatch(
                                  renameDocument(
                                      propOr("", "sha", data),
                                      propOr("", "path", data)
                                  )
                              )
                      },
                      {
                          icon: (
                              <DeleteIcon
                                  color="secondary"
                                  css={SS.deleteIcon}
                              />
                          ),
                          hint: `Delete ${propOr("", "path", data)}`,
                          onClick: () => {
                              typeof data.sha === "string" &&
                                  dispatch(deleteFile(data.sha));
                          }
                      }
                  ]
                : ([] as MuiTreeIconButtonData[]);
        },
        [project, dispatch, isOwner]
    );

    const requestChildrenData = useCallback((data, path, toggleFoldStatus) => {
        const { type } = data;
        console.log("REQUESTING CHILDREN", data, path, toggleFoldStatus);
        if (type === "blob") {
            toggleFoldStatus();
        }
    }, []);

    return (
        <>
            <div css={windowHeaderStyle}>
                <p>
                    {project ? project.name : ""}
                    <span css={SS.headIconsContainer}>
                        <Tooltip title="create new directory">
                            <span css={SS.newFolderIcon}>
                                <FontAwesomeIcon
                                    icon={faFolderPlus}
                                    size="sm"
                                    color={theme.alternativeColor.primary}
                                />
                            </span>
                        </Tooltip>
                        <Tooltip title="close window">
                            <span
                                onClick={() =>
                                    dispatch(setFileTreePanelOpen(false))
                                }
                            >
                                <FontAwesomeIcon
                                    icon={faWindowClose}
                                    size="sm"
                                    color={theme.alternativeColor.primary}
                                />
                            </span>
                        </Tooltip>
                    </span>
                </p>
            </div>
            <Tree
                className={" MuiFileTree"}
                css={SS.container}
                data={state.data}
                labelKey="path"
                valueKey="sha"
                childrenKey="tree"
                foldIcon={
                    <ArrowDropDownIcon
                        style={{ color: theme.color.primary }}
                        fontSize="large"
                    />
                }
                unfoldIcon={
                    <ArrowDropUpIcon
                        style={{ color: theme.color.primary }}
                        fontSize="large"
                    />
                }
                loadMoreIcon={
                    <MoreHorizIcon
                        style={{ color: "white" }}
                        fontSize="large"
                    />
                }
                renderLabel={renderLabel}
                pageSize={100000}
                actionsAlignRight={false}
                getActionsData={getActionsData}
                requestChildrenData={requestChildrenData}
            />
        </>
    );
};

export default FileTree;
